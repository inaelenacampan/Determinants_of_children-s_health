window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "script", "modulename": "script", "kind": "module", "doc": "<p>script</p>\n\n<p>Ce package fournit des fonctions d'appui pour la g\u00e9n\u00e9ration du notebook principal.</p>\n\n<p>Modules principaux :</p>\n\n<ul>\n<li>clean_data.py : contient les fonctions de lecture, \u00e9criture, nettoyage, imputation.</li>\n<li>analyse_data.py : contient les fonctions de visualisation.</li>\n<li>model.py : contient les fonctions li\u00e9s \u00e0 la construction de l'indice synth\u00e8tique de sant\u00e9.</li>\n</ul>\n"}, {"fullname": "script.analyse_data", "modulename": "script.analyse_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "script.analyse_data.bar_plot", "modulename": "script.analyse_data", "qualname": "bar_plot", "kind": "function", "doc": "<p>R\u00e9aliser un bar plot.</p>\n\n<p>Args :\n    year (str) : ann\u00e9es d'int\u00e9ret\n    dfs (dict) : dictionnaire des bases de donn\u00e9es\n    variable (str) : Le crit\u00e8re de regroupement.\n    guide (pd object) : Le guide des variables NSCH.</p>\n\n<p>Returns : un bar plot</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">dfs</span>, </span><span class=\"param\"><span class=\"n\">variable</span>, </span><span class=\"param\"><span class=\"n\">guide</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.mca_analysis", "modulename": "script.analyse_data", "qualname": "mca_analysis", "kind": "function", "doc": "<p>R\u00e9aliser une ACM.</p>\n\n<p>Args:\n    year (str): L'ann\u00e9e du formulaire.\n    dfs (dict): Le dictionnaire des bases des formulaires NSCH.\n    drop_columns (list) : La liste des colonnes \u00e0 filtrer.</p>\n\n<p>Returns:\n    df_mca : La base de donn\u00e9es ad\u00e9quate pour r\u00e9aliser l'ACM.\n    mca : Objet mca.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">dfs</span>, </span><span class=\"param\"><span class=\"n\">drop_columns</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.mca_plot_individuals", "modulename": "script.analyse_data", "qualname": "mca_plot_individuals", "kind": "function", "doc": "<p>Visualisation des individus de la base de donn\u00e9es dans un plan 2D.</p>\n\n<p>Args:\n    df_mca : La base de donn\u00e9es ad\u00e9quate pour r\u00e9aliser l'ACM.\n    mca : L'objet mca.</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un plot (pas de return explicite)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_mca</span>, </span><span class=\"param\"><span class=\"n\">mca</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.mca_plot_individuals_group", "modulename": "script.analyse_data", "qualname": "mca_plot_individuals_group", "kind": "function", "doc": "<p>Visualisation des individus selon un crit\u00e8re de regroument.</p>\n\n<p>Args:\n    df_mca : La base de donn\u00e9es ad\u00e9quate pour r\u00e9aliser l'ACM.\n    mca : L'objet mca.\n    variable (str) : Le crit\u00e8re de regroupement.\n    guide (pd object) : Le guide des variables NSCH.</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un plot (pas de return explicite)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_mca</span>, </span><span class=\"param\"><span class=\"n\">mca</span>, </span><span class=\"param\"><span class=\"n\">variable</span>, </span><span class=\"param\"><span class=\"n\">guide</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.mca_plot_categories", "modulename": "script.analyse_data", "qualname": "mca_plot_categories", "kind": "function", "doc": "<p>Visualisation des modalit\u00e9s (variables cat\u00e9gorielles) de la base de donn\u00e9es dans un plan 2D.</p>\n\n<p>Args:\n    df_mca : La base de donn\u00e9es ad\u00e9quate pour r\u00e9aliser l'ACM.\n    mca : L'objet mca.\n    seuil (int) : Pour mieux visualiser le graphique, combien de composantes \"principales\".</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'une figure avec 2 plot (pas de return explicite)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_mca</span>, </span><span class=\"param\"><span class=\"n\">mca</span>, </span><span class=\"param\"><span class=\"n\">seuil</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.heatmap_generator", "modulename": "script.analyse_data", "qualname": "heatmap_generator", "kind": "function", "doc": "<p>Visualisation de la matrice des corr\u00e9lations de fa\u00e7on hierarchique.</p>\n\n<p>Args:\n    df : La base de donn\u00e9es.</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un plot (pas de return explicite)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.map_united_states", "modulename": "script.analyse_data", "qualname": "map_united_states", "kind": "function", "doc": "<p>Cr\u00e9e une carte choropl\u00e8the interactive des \u00c9tats-Unis repr\u00e9sentant\nun indicateur global de sant\u00e9 des enfants pour une ann\u00e9e donn\u00e9e.</p>\n\n<p>La carte est g\u00e9n\u00e9r\u00e9e \u00e0 l\u2019aide de Folium \u00e0 partir de donn\u00e9es g\u00e9ographiques\n(GeoDataFrame) et d\u2019un DataFrame contenant les indicateurs de sant\u00e9.\nChaque \u00c9tat est color\u00e9 selon la valeur de l\u2019indicateur, allant du rouge\n(faible niveau de sant\u00e9) au vert fonc\u00e9 (meilleur niveau de sant\u00e9).</p>\n\n<p>Args:\n    df_indicator : pandas.DataFrame\n        DataFrame contenant l'indicateur de sant\u00e9 par \u00c9tat.\n        L'index doit correspondre au code FIPS des \u00c9tats (FIPSST).\n        Il doit contenir une colonne nomm\u00e9e :\n        \"indicator_global_health_<year>\".</p>\n\n<pre><code>df_geo : geopandas.GeoDataFrame\n    GeoDataFrame contenant les polygones des \u00c9tats am\u00e9ricains.\n    Doit inclure les colonnes :\n    - \"GeoFIPS\" : code FIPS sous forme de cha\u00eene\n    - \"GeoName\" : nom de l'\u00c9tat\n    - \"geometry\" : g\u00e9om\u00e9trie des \u00c9tats\n\nyear : str\n    Ann\u00e9e de l'indicateur de sant\u00e9 \u00e0 afficher sur la carte.\n</code></pre>\n\n<p>Returns:\n    folium.Map\n        Objet Folium repr\u00e9sentant la carte interactive des \u00c9tats-Unis,\n        avec une l\u00e9gende et des infobulles affichant le nom de l'\u00c9tat\n        et la valeur de l'indicateur de sant\u00e9.</p>\n\n<h2 id=\"references\">R\u00e9f\u00e9rences</h2>\n\n<p>Tutoriel Folium utilis\u00e9 :\n<a href=\"https://python-visualization.github.io/folium/latest/user_guide/geojson/geojson_popup_and_tooltip.html\">https://python-visualization.github.io/folium/latest/user_guide/geojson/geojson_popup_and_tooltip.html</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_indicator</span>, </span><span class=\"param\"><span class=\"n\">df_geo</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.analyse_data.interactive_map", "modulename": "script.analyse_data", "qualname": "interactive_map", "kind": "function", "doc": "<p>Affiche une carte interactive des \u00c9tats-Unis permettant de visualiser\nl'\u00e9volution d'un indicateur global de sant\u00e9 des enfants selon l'ann\u00e9e.</p>\n\n<p>Cette fonction utilise des widgets ipywidgets pour cr\u00e9er un menu\nd\u00e9roulant de s\u00e9lection de '\u2019ann\u00e9e. Lorsque l'ann\u00e9e change, la carte\nchoropl\u00e8the correspondante est automatiquement mise \u00e0 jour.</p>\n\n<p>Args:\n    df_indicator : pandas.DataFrame\n        DataFrame contenant les indicateurs de sant\u00e9 par \u00c9tat et par ann\u00e9e.\n        L'index doit correspondre au code FIPS des \u00c9tats (FIPSST).\n        Les colonnes doivent \u00eatre nomm\u00e9es sous la forme :\n        \"indicator_global_health_<year>\".</p>\n\n<pre><code>df_geo : geopandas.GeoDataFrame\n    GeoDataFrame contenant les informations g\u00e9ographiques des \u00c9tats\n    am\u00e9ricains (polygones, noms des \u00c9tats et codes FIPS).\n</code></pre>\n\n<p>Returns:\n    None\n        La fonction ne retourne rien. Elle affiche directement un widget\n        interactif et une carte Folium dans le notebook Jupyter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_indicator</span>, </span><span class=\"param\"><span class=\"n\">df_geo</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data", "modulename": "script.clean_data", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "script.clean_data.lecture_fichier", "modulename": "script.clean_data", "qualname": "lecture_fichier", "kind": "function", "doc": "<p>Lecture depuis l'espace de stockage S3.</p>\n\n<p>Args:\n    fs : abstraction du filesystem\n    chemin_lecture (str)\n    chemin_ecriture (str)</p>\n\n<p>Returns:\n    rien</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fs</span>, </span><span class=\"param\"><span class=\"n\">chemin_lecture</span>, </span><span class=\"param\"><span class=\"n\">chemin_ecriture</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.lecture_fichier_sas", "modulename": "script.clean_data", "qualname": "lecture_fichier_sas", "kind": "function", "doc": "<p>Lecture des fichiers sas.</p>\n\n<p>Args:\n    fs : abstraction du filesystem\n    chemin_lecture (str)\n    chemin_ecriture (str)</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un objet dataframe</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fs</span>, </span><span class=\"param\"><span class=\"n\">chemin_lecture</span>, </span><span class=\"param\"><span class=\"n\">chemin_ecriture</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.lecture_fichier_csv", "modulename": "script.clean_data", "qualname": "lecture_fichier_csv", "kind": "function", "doc": "<p>Lecture des fichiers csv.</p>\n\n<p>Args:\n    fs : abstraction du filesystem\n    chemin_lecture (str)\n    chemin_ecriture (str)</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un objet dataframe</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fs</span>, </span><span class=\"param\"><span class=\"n\">chemin_lecture</span>, </span><span class=\"param\"><span class=\"n\">chemin_ecriture</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.lecture_fichier_shapefile", "modulename": "script.clean_data", "qualname": "lecture_fichier_shapefile", "kind": "function", "doc": "<p>Lecture des fichiers g\u00e9ographiques (.shp, principalement).</p>\n\n<p>Args:\n    fs : abstraction du filesystem\n    chemin_lecture (str)\n    chemin_ecriture (str)</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un objet geopandas</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fs</span>, </span><span class=\"param\"><span class=\"n\">chemin_lecture</span>, </span><span class=\"param\"><span class=\"n\">chemin_ecriture</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.write_questions", "modulename": "script.clean_data", "qualname": "write_questions", "kind": "function", "doc": "<p>Sauvergarde des questions des variables d'interet.</p>\n\n<p>Args:\n    variables (set) : variables s\u00e9l\u00e9ctionn\u00e9es\n    guide (dataframe) : guide des variables NSCH</p>\n\n<p>Returns:\n    rien</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">guide</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.impute_values", "modulename": "script.clean_data", "qualname": "impute_values", "kind": "function", "doc": "<p>M\u00e9thode d'imputation des variables manquantes.</p>\n\n<p>Args:\n    year (str) : ann\u00e9e du formulaire NSCH.\n    df : dataframe sondage.</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un objet geopandas</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">df</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.impute_values_over_dataset", "modulename": "script.clean_data", "qualname": "impute_values_over_dataset", "kind": "function", "doc": "<p>R\u00e9alisation de l'amputation sur l'ensemble des bases de donn\u00e9es.</p>\n\n<p>Args:\n    years (list) : ann\u00e9es des enquetes NSCH\n    dfs (dict) : dictionnaire des dataset NSCH</p>\n\n<p>Returns:\n    g\u00e9n\u00e9ration d'un dictionnaire de dataframes</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">years</span>, </span><span class=\"param\"><span class=\"n\">dfs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.write_on_S3", "modulename": "script.clean_data", "qualname": "write_on_S3", "kind": "function", "doc": "<p>Ecriture parquet en S3.</p>\n\n<p>Args:\n    fs : abstraction du filesystem\n    years (list) : ann\u00e9es des enquetes NSCH\n    dfs_final (dict) : dictionnaire des dataset NSCH</p>\n\n<p>Returns:\n    rien</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fs</span>, </span><span class=\"param\"><span class=\"n\">years</span>, </span><span class=\"param\"><span class=\"n\">dfs_final</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.read_on_S3", "modulename": "script.clean_data", "qualname": "read_on_S3", "kind": "function", "doc": "<p>Lecture parquet depuis S3.</p>\n\n<p>Args:\n    fs : abstraction du filesystem\n    years (list) : ann\u00e9es des enquetes NSCH</p>\n\n<p>Returns:\n    dictionnaire de dataset NSCH</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fs</span>, </span><span class=\"param\"><span class=\"n\">years</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.test_imputed", "modulename": "script.clean_data", "qualname": "test_imputed", "kind": "function", "doc": "<p>Tester l'imputation.</p>\n\n<p>Args:\n    years (list) : ann\u00e9es des enquetes NSCH\n    dfs_final (dict) : dictionnaire des dataset NSCH</p>\n\n<p>Returns:\n    rien</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">years</span>, </span><span class=\"param\"><span class=\"n\">dfs_final</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.clean_gpd_dataframe", "modulename": "script.clean_data", "qualname": "clean_gpd_dataframe", "kind": "function", "doc": "<p>Nettoyage de la base de donn\u00e9es \u00e9conomiques.</p>\n\n<p>Args:\n    gdp (dataframe) : base de donn\u00e9es \u00e9conomiques.</p>\n\n<p>Returns:\n    base corrig\u00e9e</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdp</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.merge_gdp_on_gdf", "modulename": "script.clean_data", "qualname": "merge_gdp_on_gdf", "kind": "function", "doc": "<p>R\u00e9aliser la jointure entre les donn\u00e9es \u00e9conomiques et les donn\u00e9es g\u00e9ographiques.</p>\n\n<p>Args:\n    gdp : base de donn\u00e9es \u00e9conomiques.\n    gdf : base de donn\u00e9es g\u00e9ographiques.</p>\n\n<p>Returns:\n    dataframe obtenu avec la jointure</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdp</span>, </span><span class=\"param\"><span class=\"n\">gdf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.numeric_only", "modulename": "script.clean_data", "qualname": "numeric_only", "kind": "function", "doc": "<p>Nettoyer les types de la base de donn\u00e9es \u00e9conomiques.</p>\n\n<p>Args :\n    df : dataframe</p>\n\n<p>Returns:\n    dataframe</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">prefixes</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;2018&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2019&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2020&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2021&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2022&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2023&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;2024&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.clean_enrichment_datasets", "modulename": "script.clean_data", "qualname": "clean_enrichment_datasets", "kind": "function", "doc": "<p>Regrouper les deux fonctions pr\u00e9c\u00e9dentes.</p>\n\n<p>Args:\n    gdp : base de donn\u00e9es \u00e9conomiques.\n    gdf : base de donn\u00e9es g\u00e9ographiques.</p>\n\n<p>Returns:\n    dataframe obtenu avec la jointure, apr\u00e8s un premier nettoyage</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdp</span>, </span><span class=\"param\"><span class=\"n\">gdf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.clean_data.clean_eco_data", "modulename": "script.clean_data", "qualname": "clean_eco_data", "kind": "function", "doc": "<p>Nettoie les donn\u00e9es \u00e9conomiques :</p>\n\n<ul>\n<li>suppression des colonnes inutiles (ann\u00e9es anciennes, variables inutiles pour l'\u00e9tude)</li>\n<li>renommage de STATEFP en FIPSST pour les jointures</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_eco</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model", "modulename": "script.model", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "script.model.weighted_mean", "modulename": "script.model", "qualname": "weighted_mean", "kind": "function", "doc": "<p>Calculer la moyenne pond\u00e9r\u00e9e</p>\n\n<p>Args :\n    x : variable num\u00e9rique\n    w : poids</p>\n\n<p>Returns:\n    float - moyenne pond\u00e9r\u00e9e</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">w</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.scale_transformation", "modulename": "script.model", "qualname": "scale_transformation", "kind": "function", "doc": "<p>Applique des transformations d'\u00e9chelle et d'orientation aux variables\nd'un th\u00e8me donn\u00e9.</p>\n\n<p>Cette fonction permet :</p>\n\n<ul>\n<li>de s\u00e9lectionner les variables pertinentes pour une ann\u00e9e donn\u00e9e,</li>\n<li>d'harmoniser le sens des variables cat\u00e9gorielles (inversion d'\u00e9chelle),</li>\n<li>de transformer les variables binaires selon la logique du th\u00e8me \u00e9tudi\u00e9.</li>\n</ul>\n\n<p>Args:\n    year : str\n        Ann\u00e9e d'analyse utilis\u00e9e pour extraire le DataFrame correspondant.</p>\n\n<pre><code>dfs : dict\n    Dictionnaire de DataFrames index\u00e9 par ann\u00e9e.\n\nvariables : list\n    Liste des variables quantitatives \u00e0 inclure dans l'analyse.\n\ncat_variables : list\n    Liste des variables cat\u00e9gorielles ordinales cod\u00e9es sur une \u00e9chelle\n    de 1 \u00e0 5, dont le sens doit \u00eatre invers\u00e9 afin que des valeurs plus\n    \u00e9lev\u00e9es correspondent \u00e0 une meilleure situation de sant\u00e9.\n\nbin_variables : list\n    Liste des variables binaires (cod\u00e9es 1/2) n\u00e9cessitant une\n    transformation sp\u00e9cifique.\n\ngroups : list\n    Liste de variables suppl\u00e9mentaires (variables de regroupement et de poids)\n    \u00e0 conserver dans le DataFrame final.\n\ntheme : str\n    Th\u00e8me d'analyse. Lorsque le th\u00e8me est \"micro_eco\", les variables\n    binaires sont transform\u00e9es de fa\u00e7on sym\u00e9trique ; sinon, une\n    transformation standard est appliqu\u00e9e.\n</code></pre>\n\n<p>Returns:\n    pandas.DataFrame\n        DataFrame contenant uniquement les variables s\u00e9lectionn\u00e9es,\n        apr\u00e8s transformation des \u00e9chelles et harmonisation du sens\n        des indicateurs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">dfs</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">cat_variables</span>, </span><span class=\"param\"><span class=\"n\">bin_variables</span>, </span><span class=\"param\"><span class=\"n\">groups</span>, </span><span class=\"param\"><span class=\"n\">theme</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.state_indicator", "modulename": "script.model", "qualname": "state_indicator", "kind": "function", "doc": "<p>Calcule un sous-indicateur de sant\u00e9 agr\u00e9g\u00e9 par \u00c9tat pour un th\u00e8me donn\u00e9\net une ann\u00e9e donn\u00e9e.</p>\n\n<p>Args:\n    df_theme : pandas.DataFrame\n        DataFrame contenant les variables th\u00e9matiques d\u00e9j\u00e0 transform\u00e9es\n        (\u00e9chelles harmonis\u00e9es), ainsi que les colonnes :\n        - \"FIPSST\" : code de l'\u00c9tat\n        - \"FWC\" : poids utilis\u00e9s pour le calcul des moyennes pond\u00e9r\u00e9es.</p>\n\n<pre><code>variables : list\n    Liste des variables quantitatives entrant dans le calcul\n    du sous-indicateur.\n\ntheme : str\n    Nom du th\u00e8me \u00e9tudi\u00e9 (\"micro_eco\", \"health\", \"mental_health\"),\n    utilis\u00e9 pour nommer la colonne du sous-indicateur.\n\nyear : str\n    Ann\u00e9e d'analyse, utilis\u00e9e pour nommer la colonne du sous-indicateur.\n\nminimum : float\n    Valeur minimale th\u00e9orique utilis\u00e9e pour la\n    normalisation du sous-indicateur.\n\nmaximum : float\n    Valeur maximale th\u00e9orique utilis\u00e9e pour la\n    normalisation du sous-indicateur.\n</code></pre>\n\n<p>Returns:\n    pandas.Series\n        S\u00e9rie index\u00e9e par le code FIPS des \u00c9tats (FIPSST) contenant\n        le sous-indicateur normalis\u00e9 sur l'intervalle [0, 1] pour\n        le th\u00e8me et l'ann\u00e9e consid\u00e9r\u00e9s.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df_theme</span>, </span><span class=\"param\"><span class=\"n\">variables</span>, </span><span class=\"param\"><span class=\"n\">theme</span>, </span><span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">minimum</span>, </span><span class=\"param\"><span class=\"n\">maximum</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.calculate_indicator", "modulename": "script.model", "qualname": "calculate_indicator", "kind": "function", "doc": "<p>-- add legend</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">year</span>, </span><span class=\"param\"><span class=\"n\">dfs</span>, </span><span class=\"param\"><span class=\"n\">theme</span>, </span><span class=\"param\"><span class=\"n\">cat_variables</span>, </span><span class=\"param\"><span class=\"n\">bin_variables</span>, </span><span class=\"param\"><span class=\"n\">groups</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.economic_pca_indicator", "modulename": "script.model", "qualname": "economic_pca_indicator", "kind": "function", "doc": "<p>Construit un sous-indicateur macro-\u00e9conomique de sant\u00e9 au niveau des \u00c9tats\n\u00e0 l'aide d'une Analyse en Composantes Principales (ACP).</p>\n\n<p>Args:\n    df : pandas.DataFrame\n        DataFrame contenant les variables macro-\u00e9conomiques par \u00c9tat.\n        Doit inclure une colonne \"FIPSST\" ainsi que les variables list\u00e9es\n        dans <code>state_eco_vars</code>.</p>\n\n<pre><code>state_eco_vars : list\n    Liste des variables macro-\u00e9conomiques quantitatives utilis\u00e9es\n    pour la construction du sous-indicateur.\n\nyear : str\n    Ann\u00e9e d'analyse, utilis\u00e9e pour nommer la colonne du sous-indicateur.\n</code></pre>\n\n<p>Returns:\n    pandas.DataFrame\n        DataFrame contenant :\n        - la colonne \"FIPSST\" (code de l'\u00c9tat),\n        - la colonne \"sub_indicator_macroeco_<year>\" correspondant\n        au sous-indicateur macro-\u00e9conomique normalis\u00e9 sur [0, 1].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">state_eco_vars</span>, </span><span class=\"param\"><span class=\"n\">year</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.average_economic_indicator", "modulename": "script.model", "qualname": "average_economic_indicator", "kind": "function", "doc": "<p>Construit un sous-indicateur \u00e9conomique global par \u00c9tat en combinant\ndes dimensions micro-\u00e9conomiques et macro-\u00e9conomiques.</p>\n\n<p>Args:\n    year : str\n        Ann\u00e9e d'analyse utilis\u00e9e pour s\u00e9lectionner les donn\u00e9es et nommer\n        les colonnes des sous-indicateurs.</p>\n\n<pre><code>df_eco : pandas.DataFrame\n    DataFrame contenant les variables macro-\u00e9conomiques par \u00c9tat,\n    incluant la colonne \"FIPSST\".\n\ndfs : dict\n    Dictionnaire de DataFrames index\u00e9 par ann\u00e9e contenant les donn\u00e9es\n    micro-\u00e9conomiques issues de l'enqu\u00eate NSCH.\n\ntheme : str\n    Nom du th\u00e8me micro-\u00e9conomique utilis\u00e9 pour la construction du\n    sous-indicateur issu des donn\u00e9es individuelles.\n\ncat_variables : list\n    Liste des variables cat\u00e9gorielles ordinales n\u00e9cessitant une\n    transformation d'\u00e9chelle.\n\nbin_variables : list\n    Liste des variables binaires \u00e0 transformer selon la logique\n    du th\u00e8me \u00e9tudi\u00e9.\n\ngroups : list\n    Liste de variables suppl\u00e9mentaires conserv\u00e9es lors du calcul\n    du sous-indicateur micro-\u00e9conomique.\n\nstate_eco_vars_dict : dict\n    Dictionnaire associant \u00e0 chaque ann\u00e9e la liste des variables\n    macro-\u00e9conomiques utilis\u00e9es dans l'ACP.\n</code></pre>\n\n<p>Returns:\n    pandas.Series\n        S\u00e9rie index\u00e9e par le code FIPS des \u00c9tats (FIPSST) contenant\n        le sous-indicateur \u00e9conomique global normalis\u00e9 sur l'intervalle\n        [0, 1] pour l'ann\u00e9e consid\u00e9r\u00e9e.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">year</span>,</span><span class=\"param\">\t<span class=\"n\">df_eco</span>,</span><span class=\"param\">\t<span class=\"n\">dfs</span>,</span><span class=\"param\">\t<span class=\"n\">theme</span>,</span><span class=\"param\">\t<span class=\"n\">cat_variables</span>,</span><span class=\"param\">\t<span class=\"n\">bin_variables</span>,</span><span class=\"param\">\t<span class=\"n\">groups</span>,</span><span class=\"param\">\t<span class=\"n\">state_eco_vars_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.over_all_indicators_year", "modulename": "script.model", "qualname": "over_all_indicators_year", "kind": "function", "doc": "<p>Calcule l'ensemble des sous-indicateurs th\u00e9matiques de sant\u00e9 des enfants\nau niveau des \u00c9tats pour une ann\u00e9e donn\u00e9e.</p>\n\n<p>Cette fonction construit trois dimensions :</p>\n\n<ul>\n<li>un sous-indicateur de sant\u00e9 mentale,</li>\n<li>un sous-indicateur de sant\u00e9 physique,</li>\n<li>un sous-indicateur \u00e9conomique combinant des dimensions micro-\net macro-\u00e9conomiques.</li>\n</ul>\n\n<p>Chaque sous-indicateur est normalis\u00e9 sur l'intervalle [0, 1] et\nagr\u00e9g\u00e9 au niveau des \u00c9tats (FIPSST).</p>\n\n<p>Args:\n    year : str\n        Ann\u00e9e d'analyse utilis\u00e9e pour s\u00e9lectionner les donn\u00e9es et nommer\n        les colonnes des sous-indicateurs.</p>\n\n<pre><code>df_eco : pandas.DataFrame\n    DataFrame contenant les variables macro-\u00e9conomiques par \u00c9tat,\n    incluant la colonne \"FIPSST\".\n\ndfs : dict\n    Dictionnaire de DataFrames index\u00e9 par ann\u00e9e contenant les donn\u00e9es\n    issues de l'enqu\u00eate NSCH.\n\ngroups : list\n    Liste des variables de regroupement ou de pond\u00e9ration utilis\u00e9es\n    lors de l'agr\u00e9gation au niveau des \u00c9tats.\n\nmental_category_vars : list\n    Liste des variables cat\u00e9gorielles ordinales utilis\u00e9es pour la\n    construction du sous-indicateur de sant\u00e9 mentale.\n\nmental_bin_vars : list\n    Liste des variables binaires utilis\u00e9es pour la construction du\n    sous-indicateur de sant\u00e9 mentale.\n\nhealth_category_vars : list\n    Liste des variables cat\u00e9gorielles ordinales utilis\u00e9es pour la\n    construction du sous-indicateur de sant\u00e9 physique.\n\nhealth_bin_vars : list\n    Liste des variables binaires utilis\u00e9es pour la construction du\n    sous-indicateur de sant\u00e9 physique.\n\nNSCH_eco_cat_vars : list\n    Liste des variables cat\u00e9gorielles ordinales issues de l\u2019enqu\u00eate\n    NSCH utilis\u00e9es pour la dimension micro-\u00e9conomique.\n\nNSCH_eco_bin_vars : list\n    Liste des variables binaires issues de l\u2019enqu\u00eate NSCH utilis\u00e9es\n    pour la dimension micro-\u00e9conomique.\n\nstate_eco_vars_dict : dict\n    Dictionnaire associant \u00e0 chaque ann\u00e9e la liste des variables\n    macro-\u00e9conomiques utilis\u00e9es dans la construction de l\u2019indicateur\n    \u00e9conomique.\n</code></pre>\n\n<p>Returns:\n    tuple of pandas.DataFrame\n        Tuple contenant trois DataFrames index\u00e9s par le code FIPS des \u00c9tats :\n        - sous-indicateur de sant\u00e9 mentale,\n        - sous-indicateur de sant\u00e9 physique,\n        - sous-indicateur \u00e9conomique.</p>\n\n<pre><code>Chaque DataFrame contient une unique colonne correspondant\nau sous-indicateur et \u00e0 l'ann\u00e9e consid\u00e9r\u00e9e.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">year</span>,</span><span class=\"param\">\t<span class=\"n\">df_eco</span>,</span><span class=\"param\">\t<span class=\"n\">dfs</span>,</span><span class=\"param\">\t<span class=\"n\">groups</span>,</span><span class=\"param\">\t<span class=\"n\">mental_category_vars</span>,</span><span class=\"param\">\t<span class=\"n\">mental_bin_vars</span>,</span><span class=\"param\">\t<span class=\"n\">health_category_vars</span>,</span><span class=\"param\">\t<span class=\"n\">health_bin_vars</span>,</span><span class=\"param\">\t<span class=\"n\">NSCH_eco_cat_vars</span>,</span><span class=\"param\">\t<span class=\"n\">NSCH_eco_bin_vars</span>,</span><span class=\"param\">\t<span class=\"n\">state_eco_vars_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "script.model.global_health_over_years", "modulename": "script.model", "qualname": "global_health_over_years", "kind": "function", "doc": "<p>Construit l'indicateur global de sant\u00e9 des enfants aux \u00c9tats-Unis\npour plusieurs ann\u00e9es, au niveau des \u00c9tats.</p>\n\n<p>Args:\n    years : list\n        Liste des ann\u00e9es d'analyse.</p>\n\n<pre><code>df_eco : pandas.DataFrame\n    DataFrame contenant les variables macro-\u00e9conomiques par \u00c9tat,\n    incluant la colonne \"FIPSST\".\n\ndfs : dict\n    Dictionnaire de DataFrames index\u00e9 par ann\u00e9e contenant les donn\u00e9es\n    issues de l'enqu\u00eate NSCH.\n\ngroups : list\n    Liste des variables de regroupement ou de pond\u00e9ration utilis\u00e9es\n    lors de l'agr\u00e9gation au niveau des \u00c9tats.\n\nmental_category_vars : list\n    Liste des variables cat\u00e9gorielles ordinales utilis\u00e9es pour la\n    construction du sous-indicateur de sant\u00e9 mentale.\n\nmental_bin_vars : list\n    Liste des variables binaires utilis\u00e9es pour la construction du\n    sous-indicateur de sant\u00e9 mentale.\n\nhealth_category_vars : list\n    Liste des variables cat\u00e9gorielles ordinales utilis\u00e9es pour la\n    construction du sous-indicateur de sant\u00e9 physique.\n\nhealth_bin_vars : list\n    Liste des variables binaires utilis\u00e9es pour la construction du\n    sous-indicateur de sant\u00e9 physique.\n\nNSCH_eco_cat_vars : list\n    Liste des variables cat\u00e9gorielles ordinales issues de l\u2019enqu\u00eate\n    NSCH utilis\u00e9es pour la dimension micro-\u00e9conomique.\n\nNSCH_eco_bin_vars : list\n    Liste des variables binaires issues de l\u2019enqu\u00eate NSCH utilis\u00e9es\n    pour la dimension micro-\u00e9conomique.\n\nstate_eco_vars_dict : dict\n    Dictionnaire associant \u00e0 chaque ann\u00e9e la liste des variables\n    macro-\u00e9conomiques utilis\u00e9es dans la construction de l'indicateur\n    \u00e9conomique.\n</code></pre>\n\n<p>Returns:\n    pandas.DataFrame\n        DataFrame index\u00e9 par le code FIPS des \u00c9tats (FIPSST) contenant :\n        - l'ensemble des sous-indicateurs th\u00e9matiques par ann\u00e9e,\n        - l'indicateur global de sant\u00e9 des enfants\n        (\"indicator_global_health_<year>\") pour chaque ann\u00e9e analys\u00e9e.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">years</span>,</span><span class=\"param\">\t<span class=\"n\">df_eco</span>,</span><span class=\"param\">\t<span class=\"n\">dfs</span>,</span><span class=\"param\">\t<span class=\"n\">groups</span>,</span><span class=\"param\">\t<span class=\"n\">mental_category_vars</span>,</span><span class=\"param\">\t<span class=\"n\">mental_bin_vars</span>,</span><span class=\"param\">\t<span class=\"n\">health_category_vars</span>,</span><span class=\"param\">\t<span class=\"n\">health_bin_vars</span>,</span><span class=\"param\">\t<span class=\"n\">NSCH_eco_cat_vars</span>,</span><span class=\"param\">\t<span class=\"n\">NSCH_eco_bin_vars</span>,</span><span class=\"param\">\t<span class=\"n\">state_eco_vars_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();